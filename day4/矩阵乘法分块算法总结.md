# Triton 矩阵乘法：分块算法 vs 分组分块算法

## 概述

本文档总结了 Triton 中矩阵乘法的两种实现方式：**基础分块算法**和**分组分块算法（Grouped Blocking）**，并结合 `triton_matmul.py` 和 `triton_matmul_opt.py` 进行说明。

---

## 1. 基础分块算法（triton_matmul.py）

### 核心思想

将矩阵按照固定大小的块进行划分，每个 Triton program（线程块）负责计算输出矩阵 C 中的一个数据块。

### 实现方式

```python
# 二维网格配置
grid = (triton.cdiv(M, BLOCK_SIZE_M), triton.cdiv(N, BLOCK_SIZE_N), 1)

# 每个 program 通过二维坐标定位
pid_m = tl.program_id(0)  # M 维度的块索引
pid_n = tl.program_id(1)  # N 维度的块索引
```

### Program 调度顺序

按照**行优先（Row-Major）**顺序调度：

```
对于 M=4, N=4 的分块（假设每块大小为1）：
Program ID:  0  1  2  3
             4  5  6  7
             8  9  10 11
             12 13 14 15
```

### 特点

- 简单直观，每个 program 独立计算一个输出块
- Program 数量 = `ceil(M/BLOCK_SIZE_M) × ceil(N/BLOCK_SIZE_N)`
- 相邻 program 在 N 维度上连续

---

## 2. 分组分块算法（triton_matmul_opt.py）

### 核心思想

在基础分块的基础上，引入 **GROUP_SIZE_M** 参数，将 M 维度上的多个块组成一个"组"，改变 program 的调度顺序，使得同一组内的 program 能够更好地共享 L2 Cache。

### 实现方式

```python
# 一维网格配置
grid = (triton.cdiv(M, BLOCK_SIZE_M) * triton.cdiv(N, BLOCK_SIZE_N),)

# 分组调度逻辑
pid = tl.program_id(axis=0)
num_pid_m = tl.cdiv(M, BLOCK_SIZE_M)
num_pid_n = tl.cdiv(N, BLOCK_SIZE_N)
num_pid_in_group = GROUP_SIZE_M * num_pid_n  # 每组包含的 program 数量
group_id = pid // num_pid_in_group           # 当前 program 所属的组
first_pid_m = group_id * GROUP_SIZE_M        # 组内第一个 M 块的索引
group_size_m = min(num_pid_m - first_pid_m, GROUP_SIZE_M)  # 实际组大小
pid_m = first_pid_m + ((pid % num_pid_in_group) % group_size_m)
pid_n = (pid % num_pid_in_group) // group_size_m
```

### Program 调度顺序（GROUP_SIZE_M=2）

```
对于 M=4, N=4 的分块：

基础分块顺序：          分组分块顺序：
0  1  2  3              0  2  4  6
4  5  6  7              1  3  5  7
8  9  10 11             8  10 12 14
12 13 14 15             9  11 13 15

组0: programs 0-7   处理 M 块 [0,1]
组1: programs 8-15  处理 M 块 [2,3]
```

### 特点

- 同一组内的 program 共享 A 矩阵的相同行块
- 减少 L2 Cache 竞争，提高缓存命中率
- Program 总数不变，但调度顺序优化

---

## 3. 核心区别对比

| 特性 | 基础分块算法 | 分组分块算法 |
|------|-------------|-------------|
| **网格维度** | 二维 (M_blocks, N_blocks) | 一维 (M_blocks × N_blocks) |
| **调度顺序** | 行优先，逐行扫描 | 分组调度，组内列优先 |
| **L2 Cache 利用** | 相邻 program 访问不同 A 块 | 同组 program 共享 A 块 |
| **参数** | BLOCK_SIZE_M/N/K | 额外增加 GROUP_SIZE_M |
| **Program 数量** | M_blocks × N_blocks | 相同 |

---

## 4. 性能优化原理

### L2 Cache 竞争问题

在基础分块算法中：
- Program 0 需要 A[0:BM, :] 和 B[:, 0:BN]
- Program 1 需要 A[0:BM, :] 和 B[:, BN:2BN]
- Program 4 需要 A[BM:2BM, :] 和 B[:, 0:BN]

当大量 program 同时运行时，它们访问的数据分散在整个矩阵中，导致 L2 Cache 频繁换入换出。

### 分组优化效果

分组后：
- 组内 program 共享 A 矩阵的相同行块
- 减少了对 A 矩阵的重复加载
- L2 Cache 中的数据复用率提高

```
组0 (GROUP_SIZE_M=2):
  Program 0,2,4,6 → 需要 A[0:BM, :]
  Program 1,3,5,7 → 需要 A[BM:2BM, :]

这些 program 被调度在一起执行，共享 A 的前两个行块
```

---

## 5. 代码示例对比

### 基础分块（triton_matmul.py）

```python
@triton.jit
def _fused_linear_kernel_fwd(x_ptr, w_ptr, z_ptr, M, N, K, ...):
    # 直接使用二维 program ID
    pid_m = tl.program_id(0)
    pid_n = tl.program_id(1)

    # 计算偏移
    offs_m = pid_m * BLOCK_SIZE_M + tl.arange(0, BLOCK_SIZE_M)[:, None]
    offs_n = pid_n * BLOCK_SIZE_N + tl.arange(0, BLOCK_SIZE_N)[None, :]
    ...
```

### 分组分块（triton_matmul_opt.py）

```python
@triton.jit
def matmul_kernel(a_ptr, b_ptr, c_ptr, M, N, K, ..., GROUP_SIZE_M: tl.constexpr):
    # 一维 program ID + 分组映射
    pid = tl.program_id(axis=0)
    num_pid_m = tl.cdiv(M, BLOCK_SIZE_M)
    num_pid_n = tl.cdiv(N, BLOCK_SIZE_N)
    num_pid_in_group = GROUP_SIZE_M * num_pid_n
    group_id = pid // num_pid_in_group
    first_pid_m = group_id * GROUP_SIZE_M
    group_size_m = min(num_pid_m - first_pid_m, GROUP_SIZE_M)

    # 计算实际的 M/N 块索引
    pid_m = first_pid_m + ((pid % num_pid_in_group) % group_size_m)
    pid_n = (pid % num_pid_in_group) // group_size_m
    ...
```

---

## 6. 联系与总结

### 联系

1. **计算逻辑相同**：两种算法的核心矩阵乘法计算完全一致
2. **分块思想一致**：都是将大矩阵分成小块进行计算
3. **Program 总数相同**：只是调度顺序不同

### 区别

1. **调度策略**：分组算法通过重新映射 program ID 改变执行顺序
2. **缓存优化**：分组算法显著提高 L2 Cache 利用率
3. **适用场景**：分组算法在大矩阵上优势更明显

### 性能建议

- 小矩阵：基础分块算法足够
- 大矩阵：推荐使用分组分块算法
- GROUP_SIZE_M 通常设为 8，可根据硬件调优

---

## 7. 图示说明

### 基础分块调度

```
┌───┬───┬───┬───┐
│ 0 │ 1 │ 2 │ 3 │  ← 先完成第一行
├───┼───┼───┼───┤
│ 4 │ 5 │ 6 │ 7 │  ← 再完成第二行
├───┼───┼───┼───┤
│ 8 │ 9 │10 │11 │
├───┼───┼───┼───┤
│12 │13 │14 │15 │
└───┴───┴───┴───┘
```

### 分组分块调度（GROUP_SIZE_M=2）

```
┌───┬───┬───┬───┐
│ 0 │ 2 │ 4 │ 6 │  ┐
├───┼───┼───┼───┤  │ 组0：共享 A 的前2个行块
│ 1 │ 3 │ 5 │ 7 │  ┘
├───┼───┼───┼───┤
│ 8 │10 │12 │14 │  ┐
├───┼───┼───┼───┤  │ 组1：共享 A 的后2个行块
│ 9 │11 │13 │15 │  ┘
└───┴───┴───┴───┘
```

---

## 参考文件

- `course3/triton_matmul.py` - 基础分块算法实现
- `course4/triton_matmul_opt.py` - 分组分块算法实现
